name: package

on:
  workflow_dispatch:

concurrency:
  group: deploy-pipboot
  cancel-in-progress: true

env:
  APP_IMAGE: ${{ secrets.APP_IMAGE || vars.APP_IMAGE }}
  APP_VERSION: ${{ secrets.APP_VERSION || vars.APP_VERSION }}
  APP_NAME: ${{ secrets.APP_NAME || vars.APP_NAME }}
  APP_RESOURCES: ${{ secrets.APP_RESOURCES || vars.APP_RESOURCES }}
  SSH_USERNAME: ${{ secrets.SSH_USERNAME }}
  SSH_HOST: ${{ secrets.SSH_HOST }}

jobs:
  package:
    name: package
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 8
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '8'

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build with Maven
        run: mvn -B -DskipTests package

      - name: Build Docker image
        run: |
          docker build -t ${APP_IMAGE}:${APP_VERSION} .

      - name: Save Docker image as tarball
        run: |
          docker save ${APP_IMAGE}:${APP_VERSION} -o ${APP_IMAGE}_${APP_VERSION}.tar

      - name: Debug variables (runner)
        run: |
          echo "APP_IMAGE=$APP_IMAGE"
          echo "APP_VERSION=$APP_VERSION"
          echo "APP_NAME=$APP_NAME"
          echo "APP_RESOURCES=$APP_RESOURCES"
          echo "vars.APP_IMAGE=${{ vars.APP_IMAGE }}"
          echo "vars.APP_VERSION=${{ vars.APP_VERSION }}"
          echo "vars.APP_NAME=${{ vars.APP_NAME }}"
          echo "vars.APP_RESOURCES=${{ vars.APP_RESOURCES }}"

      - name: Prepare SSH key from secret
        run: |
          KEY_FILE="$RUNNER_TEMP/ssh_key"
          printf "%s" "${{ secrets.SSH_PRIVATE_KEY }}" > "$KEY_FILE"
          chmod 600 "$KEY_FILE"
          echo "KEY_FILE=$KEY_FILE" >> $GITHUB_ENV

      - name: Transfer image to EC2
        run: |
          scp -i "$KEY_FILE" -o StrictHostKeyChecking=no ${APP_IMAGE}_${APP_VERSION}.tar ${SSH_USERNAME}@${SSH_HOST}:/home/${SSH_USERNAME}/${APP_IMAGE}_${APP_VERSION}.tar

      - name: Load image on EC2
        run: |
          ssh -i "$KEY_FILE" -o StrictHostKeyChecking=no ${SSH_USERNAME}@${SSH_HOST} \
            "sudo docker load -i /home/${SSH_USERNAME}/${APP_IMAGE}_${APP_VERSION}.tar && rm -f /home/${SSH_USERNAME}/${APP_IMAGE}_${APP_VERSION}.tar && sudo docker images | grep ${APP_IMAGE}"

      - name: Run container on EC2
        run: |
          ssh -i "$KEY_FILE" -o StrictHostKeyChecking=no ${SSH_USERNAME}@${SSH_HOST} \
            "bash -lc 'set -euo pipefail; \
             IMG=\"${APP_IMAGE}:${APP_VERSION}\"; \
             NAME=\"${APP_NAME}\"; \
             RES=\"${APP_RESOURCES}\"; \
             if [ -z \"$NAME\" ] || [ -z \"$IMG\" ]; then \
               echo \"ERROR: NAME or IMG is empty.\"; \
               echo \"NAME=[$NAME]\"; echo \"IMG=[$IMG]\"; \
               exit 1; \
             fi; \
             if [ -z \"$RES\" ]; then \
               echo \"WARNING: APP_RESOURCES is empty. Using default /opt/docker/pip/resources.\"; \
               RES=/opt/docker/pip/resources; \
             fi; \
             sudo mkdir -p \"$RES\"; \
             if sudo docker ps -a --format {{.Names}} | grep -wq \"$NAME\"; then \
               echo Container exists, stopping/removing...; \
               sudo docker rm -f \"$NAME\" || true; \
             fi; \
             echo \"Resolved NAME=[$NAME]\"; echo \"Resolved IMG=[$IMG]\"; echo \"Resolved RES=[$RES]\"; \
             printf 'sudo docker run -d --name %q -p 3030:3030 -v %q:/opt/app/resources --restart unless-stopped %q\\n' \"$NAME\" \"$RES\" \"$IMG\"; \
             sudo docker run -d --name \"$NAME\" -p 3030:3030 -v \"$RES\":/opt/app/resources --restart unless-stopped \"$IMG\"; \
             sudo docker ps --filter name=\"$NAME\" --format \"running: {{.Names}} -> {{.Image}}\"'"
